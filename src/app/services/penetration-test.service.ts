import { Injectable } from '@angular/core';
import { PenetrationTest, PenetrationTestResults } from '../models/penetration-test.model';
import { AngularFirestore } from '@angular/fire/firestore';
import { SetupService } from './setup.service';
import { Setup } from '../models/setup.model';
import { AuthService } from './auth.service';
import { DebugService } from './debug.service';
import { promiseTimeout } from '../helpers/promise.helper';

@Injectable({
  providedIn: 'root'
})
export class PenetrationTestService {

  private setup: Setup;
  tests: PenetrationTest[];
  private repetitiveTests: { [key: string]: () => Promise<PenetrationTestResults> };
  private timeout: number = 10000; // ms

  constructor(
    private setupService: SetupService,
    private authService: AuthService,
    private debugService: DebugService,
    private db: AngularFirestore
  ) {
    this.setup = this.setupService.get();
    this.repetitiveTests = {
      // Read test
      read: () => new Promise((resolve, reject) => {
        const results: PenetrationTestResults = { success: false, details: [] };
        const promises: Promise<any>[] = [];
        for (const collection of this.setup.miscellaneous.collections) {
          const promise = this.db.collection(collection).get().toPromise().then(() => {
            results.details.push({ description: `Read from ${collection} collection` });
            results.success = true;
          }).catch((error: Error) => {
            results.details.push({
              description: `Read from ${collection} collection`,
              error: error?.message
            });
          }).finally(() => {
            this.debugService.log('read results:', results);
          });
          promises.push(
            promiseTimeout(this.timeout, promise).catch((error: string) => {
              results.details.push({
                description: `Read from ${collection} collection`,
                error: error
              });
            })
          );
        }
        Promise.all(promises).finally(() => {
          resolve(results);
        });
      }),
      // Write test
      write: () => new Promise((resolve, reject) => {
        const results: PenetrationTestResults = { success: false, details: [] };
        const promises: Promise<any>[] = [];
        for (const collection of this.setup.miscellaneous.collections) {
          const promise = this.db.collection(collection).add({}).then((doc) => {
            results.details.push({ description: `Write to ${collection} collection` });
            results.success = true;
            if (this.setup.miscellaneous.clearTestData) {
              doc.delete();
            }
          }).catch((error: Error) => {
            results.details.push({
              description: `Write to ${collection} collection`,
              error: error?.message
            });
          }).finally(() => {
            this.debugService.log('write results:', results);
          });
          promises.push(
            promiseTimeout(this.timeout, promise).catch((error: string) => {
              results.details.push({
                description: `Write to ${collection} collection`,
                error: error
              });
            })
          );
        }
        Promise.all(promises).finally(() => {
          resolve(results);
        });
      })
    };
    // Main tests
    this.tests = [
      {
        description: 'Read test (without authentication)',
        run: () => this.repetitiveTests.read()
      },
      {
        description: 'Write test (without authentication)',
        run: () => this.repetitiveTests.write()
      }
    ];
    // Auth tests
    for (const key of Object.keys(this.setup.authentication)) {
      if (this.setup.authentication[key].enabled) {
        const label = this.getAuthenticationLabel(key);
        this.tests.push({
          description: `Read test using ${label} authentication`,
          run: () => new Promise((resolve, reject) => {
            const results: PenetrationTestResults = { success: false, details: [] };
            this.authService.signIn(this.setup.authentication[key]).then(async () => {
              results.details.push({ description: 'Authentication' });
              results.success = true;
              const readTestResults = await this.repetitiveTests.read();
              results.details.push(...readTestResults.details);
            }).catch((error: Error) => {
              results.details.push({
                description: 'Authentication',
                error: error?.message
              });
            }).finally(() => {
              //this.authService.signOut(); // can be omitted since it's done at the end of the following write test
              resolve(results);
            });
          })
        });
        this.tests.push({
          description: `Write test using ${label} authentication`,
          run: () => new Promise((resolve, reject) => {
            const results: PenetrationTestResults = { success: false, details: [] };
            this.authService.signIn(this.setup.authentication[key]).then(async () => {
              results.details.push({ description: 'Authentication' });
              results.success = true;
              const writeTestResults = await this.repetitiveTests.write();
              results.details.push(...writeTestResults.details);
            }).catch((error: Error) => {
              results.details.push({
                description: 'Authentication',
                error: error?.message
              });
            }).finally(() => {
              this.authService.signOut();
              resolve(results);
            });
          })
        });
      }
    }
  }

  private getAuthenticationLabel(key: string) {
    switch(key) {
      case 'emailAndPassword':
        return 'email and password';
      default:
        return key;
    }
  }

}
