import { Component, OnInit, OnDestroy } from '@angular/core';
import { DatabaseConfigSample } from 'src/app/models/database-config.model';
import { Setup } from 'src/app/models/setup.model';
import { SetupService } from 'src/app/services/setup.service';
import { databaseConfigValidator, parseDatabaseConfig } from 'src/app/validators/database-config.validator';
import { stringify } from 'src/app/helpers/parser.helper';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { DebugService } from 'src/app/services/debug.service';
import { takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';

@Component({
  selector: 'app-setup',
  templateUrl: './setup.component.html',
  styleUrls: ['./setup.component.scss']
})
export class SetupComponent implements OnInit, OnDestroy {

  setup: Setup = new Setup();
  readonly databaseConfigSample: string = DatabaseConfigSample;
  disableStartButton: boolean = false;
  setupForm: FormGroup;
  private componentDestroy: Subject<void> = new Subject();

  constructor(
    private setupService: SetupService,
    private debugService: DebugService,
    private formBuilder: FormBuilder
  ) {
    // Setup form validation rules
    this.setupForm = this.formBuilder.group({
      databaseConfig: ['', [Validators.required, databaseConfigValidator]],
      anonymousAuthentication: [false, null],
      emailAndPasswordAuthentication: [false, null],
      email: ['', [Validators.email, Validators.required]],
      password: ['', [Validators.required]],
      jwtAuthentication: [false, null],
      token: ['', [Validators.required]],
      collections: [[], [Validators.required]],
      clearTestData: [false, null]
    });
    // Update rules depending on checked options
    this.setupForm.get('emailAndPasswordAuthentication').valueChanges.pipe(
      takeUntil(this.componentDestroy)
    ).subscribe((enabled: boolean) => {
      if (enabled) {
        this.setupForm.controls.email.setValidators([Validators.email, Validators.required]);
        this.setupForm.controls.password.setValidators([Validators.required]);
      } else {
        this.setupForm.controls.email.setValidators(null);
        this.setupForm.controls.password.setValidators(null);
      }
    });
    this.setupForm.get('jwtAuthentication').valueChanges.pipe(
      takeUntil(this.componentDestroy)
    ).subscribe((enabled: boolean) => {
      if (enabled) {
        this.setupForm.controls.token.setValidators([Validators.required]);
      } else {
        this.setupForm.controls.token.setValidators(null);
      }
    });
  }

  ngOnInit(): void {
    // Fetch setup
    const setup: Setup = this.setupService.get();
    if (setup) {
      this.setup = {...this.setup, ...setup};
      if (this.setup.databaseConfig) {
        this.setup.databaseConfig = stringify(this.setup.databaseConfig as any) as any;
      }
    }
    (this.setup.authentication.emailAndPassword as any).isPasswordVisible = false;
  }

  ngOnDestroy(): void {
    this.componentDestroy.next();
    this.componentDestroy.complete();
  }

  submitForm(): void {
    for (const key in this.setupForm.controls) {
      this.setupForm.controls[key].markAsDirty();
      this.setupForm.controls[key].updateValueAndValidity();
    }
    this.debugService.log('is setupForm valid:', this.setupForm.valid);
    if (this.setupForm.valid) {
      this.disableStartButton = true;
      const setup: Setup = {...this.setup}; // Clone setup object (for modification)
      // Remove unwanted data
      delete (setup.authentication.emailAndPassword as any).isPasswordVisible;
      // Parse database config
      setup.databaseConfig = parseDatabaseConfig(setup.databaseConfig as any);
      // Save setup
      this.setupService.save(setup);
      // Start
      window.open('./start', '_self');
    }
  }

}
